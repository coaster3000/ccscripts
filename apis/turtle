--[[
	Name: Turtle Complete
	Author: Chris K (Coaster3000)
	Creation Date: 6/4/13
	Updated Date: 7/10/13
	Version: 0.2 build 40
	Flavor: API Replacement / wrapper

	COPYRIGHT NOTICE
	Â© Chris K 2013, Some Rights Reserved 
	Except where otherwise noted, this work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0

	You are free:
		* to Share - to copy, distribute and transmit the work in accordance that is stays under non profit distribution
		* to Remix - to adapt the work

	Under the following conditions:
		* Attribution. You must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of the work).
   		* Share Alike. If you alter, transform, or build upon this work, you may distribute the resulting work only under the same, similar or a compatible license.
   		* Non-Profit. You must distribute it in a non-profit way.
   		* For any reuse or distribution, you must make clear to others the license terms of this work. The best way to do this is with a link to this web page.
		* Any of the above conditions can be waived if you get permission from the copyright holder.
		* Nothing in this license impairs or restricts the author's moral rights.
	
		
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/. 

	]]
	local nativeassert = assert

local function assert(condition, msg, level) level = (level or 1) + 1 if not condition then error(msg, level) end return condition end -- Custom assert function. Based of theOriginalBit's assert function link: http://theoriginalbit.net46.net/index.html

local function yieldme()
	os.queueEvent("nothing")
	coroutine.yield()
end

if not turtle then
	error( "Cannot load turtle API on computer" )
end
turtlenative = turtle.nativeturtle or turtle
native = turtle.native or turtle

local function wrap( _sCommand )
	return function( ... )
		local id = native[_sCommand]( ... )
		local event, responseID, success
		while event ~= "turtle_response" or responseID ~= id do
			event, responseID, success = os.pullEvent( "turtle_response")
		end
		return success
	end
end

local turtle2 = {}
turtle2["getItemCount"] = native.getItemCount
turtle2["getItemSpace"] = native.getItemSpace
turtle2["getFuelLevel"] = native.getFuelLevel

for k,v in pairs( native ) do
	if type (k) == "string" and type(v) == "function" then
		if turtle2[k] == nil then
			turtle2[k] = wrap(k)
		end
	end
end

local env = getfenv()
for k,v in pairs( turtle2 ) do
	env[k] = v
end

-- End Globalization --

----Data Handling----


------------------
---- Tracking ----

-- Position data
local position = {}
position.x = 0
position.y = 0
position.z = 0
position.dir = 0

local function cust_fmod(num, div)
	local ret = math.fmod(num, div)
	if ret < 0 then
		ret = (div - 1) + ret
	end
	return ret
end

function getX() 
	local ret = position.x
	return ret
end

function getY()
	local ret = position.y
	return ret
end

function getZ()
	local ret = position.z
	return ret
end

function getDirection()
	local ret = position.dir
	return ret
end

function calibrate(_x, _y, _z, _dir)
	local x,y,z dir = nil,nil,nil,nil
	if (type(_x) == "table") then
		for k, v in ipairs(_x) do
			if (k=="x") then x = v
			elseif (k=="y") then y = v
			elseif (k=="z") then z = v
			elseif (k=="dir") then dir = v
			end
			if (x and y and z and dir) then
				x = _x[1]
				y = _x[2]
				z = _x[3]
				dir = _x[4]
			end
			x = x or getX()
			y = y or getY()
			z = z or getZ()
			dir = dir or getDirection()
		end
	else
		x = tonumber(_x) or getX()
		y = tonumber(_y) or getY()
		z = tonumber(_z) or getZ()
		dir = tonumber(_dir) or getDirection()
	end
	position.x = x
	position.y = y
	position.z = z
	position.dir = dir
end

-- End position data
local slot = 1
native.select(1)
local b = {}

function b.select(_slot)
	assert(type(_slot)=="number","Must be a number")
	assert((_slot > 0 and _slot < 17), "Invalid argument: Out of index '"..tostring(_slott).."'")
	local good = turtlenative.select(_slot)
	if good then
		slot = _slot
	end
	return good
end

function select(_slot)
	return b.select(_slot)
end

function getSlot()
	local s = slot
	return s
end

-- Breakers

local maxAttempts = 500

function getMaxAttempts() local a = maxAttempts return a end -- It is written this way to make sure variable is not publicized.

function setMaxAttempts(num)
	num = num or maxAttempts
	maxAttempts = num
end
-- End Breakers


------------------
---- Fuel --------

function hasFuel( ammount )
	return turtlenative.getFuelLevel() >= (ammount or 1)
end

function isFuel(slot)
	local lastSlot = getSlot()
	slot = slot or lastSlot
	b.select(slot)
	local good = refuel(0)
	b.select(lastSlot)
	return good
end

function refuel( ammount , advanced)
	assert(type(ammount) == "number", "Invalid Argument: Expected number. Got "..type(ammount),2)
	if advanced == nil then
		advanced = true
	end
	if advanced then
		if not hasFuel(ammount) then
			for i=1,16 do
				b.select(i)
				while getItemCount(i) >= 1 and isFuel(i) do
					if hasFuel(ammount) then
						return true
					elseif not refuel(1, false) then
						break
					end
				end
			end
			return false
		else
			return true
		end
	else
		return turtlenative.refuel(ammount)
	end
end

------------------
---- Movement ----

-- Rotation --
function turnRight()
	local good = turtlenative.turnRight()
	if good then
		position.dir = position.dir + 1
	end
	return good
end

function turnLeft()
	local good = turtlenative.turnLeft()
	if good then
		position.dir = position.dir - 1
	end
end

function turnAround( _useLeft)
	if _useLeft then
		turnLeft()
		turnLeft()
	else
		turnRight()
		turnRight()
	end
end

function spin( _count, _useLeft )
	local count = _count or 1
	for i=1,count do
		turnAround(_useLeft)
		turnAround(_useLeft)
	end
end

function shakeNo(_alt)
	if _alt then
		turnLeft()
		turnAround()
		turnLeft()
	else
		turnRight()
		turnAround(true)
		turnRight()
	end
end

function orient(dir)
	local d = getDirection()

	dir = dir or 0
	assert((type(dir)=="string" or type(dir)=="number"))
	
	local t = nil
	if dir == "north" or dir == "origin" then
		t = 0
	elseif dir == "east" then
		t = 1
	elseif dir == "south" then
		t = 2
	elseif dir == "west" then
		t = 3
	else
		t = dir
	end
		
	assert(t, dir.." was not a valid direction.")
	local count = 0
	while direction ~= t do
		turnLeft();
		count = count + 1
		if count > 4 then
			orient(d) --So help me god if this turns into infinite loop. It should be impossible to!!
			error("Turtle failed to orient to direction "..dir)
		end
		break
	end
end

function turn(direction)
	assert(direction,"Must specify a direction!")
	direction = string.lower(direction)
	if direction == "left" then
		turnLeft()
	elseif direction == "right" then
		turnRight()
	elseif (direction == "back") or (direction == "turnaround") or (direction == "around") then
		turnAround()
	elseif (direction == "forward") or (direction == "straight") then
		return
	else
		error("'"..direction.."' is not a valid direction. See documentation.")
	end
end

-- Motion --
function forward(_count)
	if not _count then
		local good = turtlenative.forward()
		if good then
			local m = cust_fmod(position.dir, 4)
			if m == 0 then position.x = position.x + 1
			elseif m == 1 then position.z = position.z + 1
			elseif m == 2 then position.x = position.x - 1
			elseif m == 3 then position.z = position.z - 1
			else print("An internal navigation error has occured in the custom turtle api...")
			end
		end
		return good
	end
	local good = 0
	assert(_count > 0,"Must specify a number above 0")
	assert(getFuelLevel() > _count,"Not enough fuel for '".._count.."' moves.")
	for i=1,_count do
		yieldme()
		if forward() then
			good = good + 1
		end
	end
	return good
end

function back(_count)
	if not _count then
		local good = turtlenative.back()
		if good then
			local m = cust_fmod(position.dir, 4)
			if m == 0 then position.x = position.x - 1
			elseif m == 1 then position.z = position.z - 1
			elseif m == 2 then position.x = position.x + 1
			elseif m == 3 then position.z = position.z + 1
			else print("An internal navigation error has occured in the custom turtle api...")
			end
		end
		return good
	end
	local good = 0
	assert(_count > 0,"Must specify a number above 0")
	assert(getFuelLevel() > _count,"Not enough fuel for '".._count.."' moves.")
	for i=1,_count do
		yieldme()
		if back() then
			good = good + 1
		end
	end
	return good
end

function up(_count)
	if not _count then
		local good = turtlenative.up()
		if good then
			position.y = position.y + 1
		end
		return good
	end
	local good = 0
	assert(_count > 0,"Must specify a number above 0")
	assert(getFuelLevel() > _count,"Not enough fuel for '".._count.."' moves.")
	for i=1,_count do
		yieldme()
		if up() then
			good = good + 1
		end
	end
	return good
end

function down(_count)
	if not _count then
		local good = turtlenative.down()
		if good then
			position.y = position.y - 1
		end
		return good
	end
	local good = 0
	assert(_count > 0,"Must specify a number above 0")
	assert(getFuelLevel() > _count,"Not enough fuel for '".._count.."' moves.")
	for i=1,_count do
		yieldme()
		if down() then
			good = good + 1
		end
	end
	return good
end

function tillBlock(direction)
	direction = direction or "forward"
	turn(direction)
	while not detect() do
		assert(hasFuel(), "Ran out of fuel.")
		forward()
		yieldme()
	end
end

---------------
----DIGGING----
function dig(advanced) 
	local good = turtlenative.dig()
	local ret = good
	if advanced then
		while good do
			sleep(0.4)
			good = dig()
		end
	end
	return ret
end

function digUp(advanced)
	local good = turtlenative.digUp()
	local ret = good
	if advanced then
		while good do
			sleep(0.4)
			good = digUp()
		end
	end
	return ret
end

function tunnelUp(count, _refuelCheck)
	assert(type(count)=="number", "Invalid Argument: Must specify a number.",0)
	assert((count > 0), "Invalid Argument: Number must be above 0.",0)
	local refuelCheck = nil
	if _refuelCheck == nil then
		refuelCheck = true
	else
		refuelCheck = _refuelCheck
	end
	if refuelCheck and (count > 0) then
		if not refuel(count, true) then
			error("Not enough fuel...")
		end
	end
	for i=1,count do
		digUp(true)
		local tries = 0
		while not up() and hasFuel() do
			digUp(true)
			attackUp()
			if tries > getMaxAttempts() and getMaxAttempts() ~= -1 then
				error("Attempted action too many times.")
			end
		end
	end
end

function tunnelDown(count, _refuelCheck)
	assert(type(count)=="number", "Invalid Argument: Must specify a number.",0)
	assert((count > 0)or (count == -1), "Invalid Argument: Number must be above 0 or -1 for infinite.",0)
	local refuelCheck = nil
	if _refuelCheck == nil then
		refuelCheck = true
	else
		refuelCheck = _refuelCheck
	end
	if refuelCheck and (count > 0) then
		if not refuel(count, true) then
			error("Not enough fuel...")
		end
	end
	if count ~= -1 then
		for i=1,count do
			local tries = 0
			digDown()
			while not down() and hasFuel() do
				digDown()
				attackDown()
				if tries > getMaxAttempts() and getMaxAttempts() ~= -1 then
					error("Attempted action too many times.")
				end
			end
		end
	else
		while true do
			local tries = 0
			while not down() and hasFuel() do
				yieldme()
				digDown()
				attackDown()
				if tries > getMaxAttempts() and getMaxAttempts() ~= -1 then
					return
				end
				tries = tries + 1
			end
		end
	end
end

function tunnel(count, _refuelCheck, _height)
	assert(type(count)=="number", "Invalid Argument: Must specify a number.",0)
	assert((count > 0) or (count == -1), "Invalid Argument: Number must be above 0 or -1 for infinite.",0)
	height = _height or 1
	local refuelCheck = nil
	if _refuelCheck == nil then
		refuelCheck = true
	else
		refuelCheck = _refuelCheck
	end
	if refuelCheck and (count > 0) then
		if not refuel(count, true) then
			error("Not enough fuel...")
		end
	end
	if count ~= -1 then
		for i=1,count do
			dig(true)
			local tries = 0
			while not forward() and hasFuel() do
				dig(true)
				if height > 1 then digUp(true) end
				if height > 2 then digDown() end
				attack()
				tries = tries + 1
				if tries > getMaxAttempts() and getMaxAttempts() ~= -1 then
					error("Attempted action too many times.")
				end
			end
		end
	else
		while true do
			local tries = 0
			while not forward() and hasFuel() do
				dig(true)
				if height > 1 then digUp(true) end
				if height > 2 then digDown() end
				attack()
				tries = tries + 1
				if tries > getMaxAttempts() and getMaxAttempts() ~= -1 then
					return
				end
			end
		end
	end
end
-- Inventory Manipulation --
----------------------------
function dropAllSame(slot)
	assert(type(slot) == "number", "Must specify a slot number")
	for i=1,16 do
		if i~=slot then
			b.select(i)
			if compareTo(slot) then
				drop()
			end
		end
	end
end

function dropDownAllSame(slot)
	assert(type(slot) == "number", "Must specify a slot number")
	for i=1,16 do
		if i~=slot then
			b.select(i)
			if compareTo(slot) then
				dropDown()
			end
		end
	end
end

function dropUpAllSame(slot)
	assert(type(slot) == "number", "Must specify a slot number")
	for i=1,16 do
		if i~=slot then
			b.select(i)
			if compareTo(slot) then
				dropUp()
			end
		end
	end
end

function countAllItems()
	local ammount = 0
	for i=1,16 do
		b.select(i)
		ammount = ammount + getItemCount(i)
	end
	return ammount
end

function countSlotItems(fSlot, tSlot)
	local ammount = 0
	for i=fSlot,tSlot do
		b.select(i)
		ammount = ammount + getItemCount(i)
	end
	return ammount
end

-- Warning: This function depends on at least one empty inventory slot.
function swapTransfer(slot)
	assert(type(slot)=="number", "Must specify a slot number")
	local a = 0
	local lastslot = getSlot()
	for i=1,16 do --Find open slot
		if getItemCount(i) == 0 then
			a = i
			break
		end
	end
	if a == 0 then
		return false
	end
	-- For better visibility and readability.
	local slot1 = lastSlot
	local slot2 = slot
	local slot3 = a

	--[[
		1 -> 3
		2 -> 1	X	3 -> 1
		3 -> 2	X	2 -> 1
		]]--
	local good = true
	b.select(slot1)
	if	transferTo(slot3) then
		b.select(slot2)
		if	transferTo(slot1) then
			b.select(slot3)
			if	transferTo(slot2) then
				b.select(slot1)
			else
				good = false
				b.select(slot2)
				transferTo(slot1)
				b.select(slot3)
				transferTo(slot1)
			end
		else
			good = false
			b.select(slot3)
			transferTo(slot1)
		end
	else
		good = false
	end
	return good
end

--[[
	Disclaimer: 
	Due to the limited functionality of CC Turtle's
	It is impossible to actually sort an inventory.

	This method is used to put all items of same match from the compareTo methods
	Next to each other. So that it resembles some sort of clean inventory.
	]]--
function sortInventory()

	error("This api is not ready yet.")
end
